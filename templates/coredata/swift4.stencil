import CoreData
import Foundation

// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length
// swiftlint:disable attributes

// swiftlint:disable identifier_name line_length type_body_length
{% set accessModifier %}{% if param.publicAccess %}public{% else %}internal{% endif %}{% endset %}
{% for model in models %}
{% for name, entity in model.entities %}
{% set superclass %}{{ model.entities[entity.superentity].className | default:"NSManagedObject" }}{% endset %}
{% set entityClassName %}{{ entity.className | default:entity.name }}{% endset %}
{% set override %}{% if superclass != "NSManagedObject" %}override {% endif %}{% endset %}
@objc({{ entityClassName }})
{{ accessModifier }} class {{ entityClassName }}: {{ superclass }} {

    {{ override }}{{ accessModifier }} class func entityName() -> String {
        return "{{ entity.name }}"
    }

    {{ override }}{{ accessModifier }} class func entity(in managedObjectContext: NSManagedObjectContext) -> NSEntityDescription? {
        return NSEntityDescription.entity(forEntityName: entityName(), in: managedObjectContext)
    }

    @nonobjc {{ accessModifier }} class func fetchRequest() -> NSFetchRequest<{{ entityClassName }}> {
        return NSFetchRequest<{{ entityClassName }}>(entityName: entityName())
    }

    {% for attribute in entity.attributes %}
    @NSManaged {{ accessModifier }} var {{ attribute.name }}: {{ attribute.typeName }}{% if attribute.usesScalarValueType == false %}{% if attribute.isOptional %}?{% else %}!{% endif %}{% endif %}

    {% endfor %}
    {% for relationship in entity.relationships %}
    {% if relationship.isToMany %}
    @NSManaged {{ accessModifier }} var {{ relationship.name }}: {% if relationship.isOrdered %}NSOrderedSet{% else %}NSSet{% endif %}

    {% else %}
    @NSManaged {{ accessModifier }} var {{ relationship.name }}: {{ model.entities[relationship.destinationEntity].className | default:"NSManagedObject" }}{% if relationship.isOptional %}?{% endif %}

    {% endif %}
    {% endfor %}
    {% for fetchedProperty in entity.fetchedProperties %}
    @NSManaged {{ accessModifier }} let {{ fetchedProperty.name }}: [{{ fetchedProperty.fetchRequest.entity }}]
    {% endfor %}
}

{% for relationship in entity.relationships %}
{% if relationship.isToMany %}
{% set destinationEntityClassName %}{{ model.entities[relationship.destinationEntity].className | default:"NSManagedObject" }}{% endset %}
{% set collectionClassName %}{% if relationship.isOrdered %}NSOrderedSet{% else %}NSSet{% endif %}{% endset %}
extension {{ entityClassName }} {

    {% if relationship.isOrdered %}
    @objc(insertObject:in{{ relationship.name | upperFirstLetter }}AtIndex:)
    @NSManaged public func insertInto{{ relationship.name | upperFirstLetter }}(_ value: {{ destinationEntityClassName }}, at idx: Int)

    @objc(removeObjectFrom{{ relationship.name | upperFirstLetter }}AtIndex:)
    @NSManaged public func removeFrom{{ relationship.name | upperFirstLetter }}(at idx: Int)

    @objc(insert{{ relationship.name | upperFirstLetter }}:atIndexes:)
    @NSManaged public func insertInto{{ relationship.name | upperFirstLetter }}(_ values: [{{ destinationEntityClassName }}], at indexes: NSIndexSet)

    @objc(remove{{ relationship.name | upperFirstLetter }}AtIndexes:)
    @NSManaged public func removeFrom{{ relationship.name | upperFirstLetter }}(at indexes: NSIndexSet)

    @objc(replaceObjectIn{{ relationship.name | upperFirstLetter }}AtIndex:withObject:)
    @NSManaged public func replace{{ relationship.name | upperFirstLetter }}(at idx: Int, with value: {{ destinationEntityClassName }})

    @objc(replace{{ relationship.name | upperFirstLetter }}AtIndexes:withOneToMany:)
    @NSManaged public func replace{{ relationship.name | upperFirstLetter }}(at indexes: NSIndexSet, with values: [{{ destinationEntityClassName }}])

    {% endif %}
    @objc(add{{ relationship.name | upperFirstLetter }}Object:)
    @NSManaged public func addTo{{ relationship.name | upperFirstLetter }}(_ value: {{ destinationEntityClassName }})

    @objc(remove{{ relationship.name | upperFirstLetter }}Object:)
    @NSManaged public func removeFrom{{ relationship.name | upperFirstLetter }}(_ value: {{ destinationEntityClassName }})

    @objc(add{{ relationship.name | upperFirstLetter }}:)
    @NSManaged public func addTo{{ relationship.name | upperFirstLetter }}(_ values: {{ collectionClassName }})

    @objc(remove{{ relationship.name | upperFirstLetter }}:)
    @NSManaged public func removeFrom{{ relationship.name | upperFirstLetter }}(_ values: {{ collectionClassName }})

}

{% endif %}
{% endfor %}

{% if model.fetchRequestsByEntityName[entity.name].count > 0 %}
extension {{ entityClassName }} {

    {% for fetchRequest in model.fetchRequestsByEntityName[entity.name] %}
    {% set resultTypeName %}{% if fetchRequest.resultType == "Object" %}{{ entityClassName }}{% elif fetchRequest.resultType == "Object ID" %}NSManagedObjectID{% elif fetchRequest.resultType == "Dictionary" %}[String: Any]{% endif %}{% endset %}
    class func fetch{{ fetchRequest.name | upperFirstLetter }}(managedObjectContext: NSManagedObjectContext{% for variableName, variableType in fetchRequest.substitutionVariables %}, {{ variableName | lowerFirstWord }}: {{ variableType }}{% endfor %}) throws -> [{{ resultTypeName }}] {
        guard let persistentStoreCoordinator = managedObjectContext.persistentStoreCoordinator else {
            fatalError("Managed object context has no persistent store coordinator for getting fetch request templates")
        }
        let model = persistentStoreCoordinator.model
        let substitutionVariables: [String: Any] = [
            {% for variableName, variableType in fetchRequest.substitutionVariables %}
            "{{ variableName }}": {{ variableName | lowerFirstWord }}
            {% empty %}
            :
            {% endfor %}
        ]

        guard let fetchRequest = model.fetchRequestFromTemplate(withName: "{{ fetchRequest.name }}", substitutionVariables: substitutionVariables) else {
            fatalError("No fetch request template named '{{ fetchRequest.name }}' found.")
        }

        return try managedObjectContext.fetch(fetchRequest) as! [{{ resultTypeName }}]
    }
    {% endfor %}

}
{% endif %}
{% endfor %}
{% endfor %}
// swiftlint:enable identifier_name line_length type_body_length
